RcStatLog requirements:

NOTE: wfStatus could either be a global variable OR a per "component"
    (e.g., MAC, SIS, etc.) variable.  I'm leaning towards the later because
    this would allow the wfstat utility to disable/enable hexdump, logging
    (and maybe even the stat collection) of particular components.  To do this
    the client (say MocbAdaptor) would do (on init):
        StatLogComponent wfStatus 
            = statLogger.getWfStatusComponent<MocbAdaptorComponent>("MocbAdaptor");
    then operate on the wfStatus (as specified below).
    The wfstat utility could do:
        > ./wfStatus --get-registered-components
            ...
            MocbAdaptor
            ...
        > ./wfStatus --disable MocbAdaptor [hexdump|log|stat|all] #the default would be all
    OR
        > ./wfStatus --enable MocbAdaptor [hexdump|log|stat|all] #the default would be all

    ISSUE: the wfStatus application will have to enable/disable per-Component stats/logs
       by writing into the Component's "isEnabled" variable in SHM

NOTE: the circular buffer shms need to be protected with either a mutex, this could be a performance issue ...
    One way to fix is to have fixed size sub-buffers in the circular buffer, and when the user
    logs (or hexdumps):
        writeLog(char* str, size_t len)
        {
            size_t num_sub_bufs = CEIL_DIVIDE(len, sub_buf_size);
            size_t sub_buf_idx_start
            lock
            {
                sub_buf_idx_start = next_sub_buf_idx;
                next_sub_buf_idx = (next_sub_buf_idx + num_sub_bufs)%NUM_SUB_BUFS
            }
            //Now copy in str to the location specified by sub_buf_idx_start
            //  with wrap-around
        }

NOTE: WfStatLogger should be a generic type that does not depend on all the component types.  This
    way we can avoid recompiling the entire waveform when the WfStatLogger.h changes.  In order to make
    this work, the WfStatLogger.cpp will instantiate the eTDRS-specific layout of shared_memory
    (this file will depend on all the component stat types).

* Pkt HexDump:
   INTERFACE:
        wfStatus.hexDump(buffer, len, "Identifier");
   Will create an entry in the HEX_DUMP shm circular buffer:
         <Component>:Identifier, size=<len>, timestamp=<current timestamp>
                01 02 03 ....
                ab ac ....
   where <Component> would be the string passed into registerWfStatusComponent()

* Logger:
    INTERFACE:
      either:
        wfStatus.getLogger() << "Some text ... " << foo ;
      or:
        wfStatus.logfmt("Some text ...  %d, %s", var, str);

      Both will prepend the current timestamp to the string 
      and copy it to the LOGGING shm circular buffer
    NICE TO HAVES:
        -- A way to specify if a timestamp is to be prepended.
        -- wfStatus.logError("text");
            this will also copy the string to the LOGGING buffer.  In addition
            it will copy the LOGGING shm (maybe the others as well)
            to a temporary location so it can be inspected later without
            having to worry about logging rollovers.  Also would be nice
            if the copy didn't take place immediately because it might 
            be useful to see how the waveform reacts to the fault in the
            immediate future.

* Stat:
    INTERFACE:
        * To increment a static-location counter or statistic;
                wfStatus.addStat<MocbQueueDownTag>(1);
            or
                wfStatus.addStat<SnrStatTag>(45.0);
        * To add stat requiring runtime offset info:
                wfStatus.addStat<PerNbrSnrStatTag>(nbrId, 45.0);
        * To add stat requiring multiple runtime indicies:
                wfStatus.addStat<PerNbrRxStatusTag>(nbrId, rxstatus, 1);
            Here the traits of PerNbrRxStatusTag will know how to handle the args

    NICE TO HAVES:
        -- Need a way to reset the statistics via the wfstat.  This is simple
           for the trivial stats, but the boost::accumulator stats are more
           difficult because their guts are not stored in the STAT shm --
           only their serializations are stored.  One possibility is for 
           wfstat to put some sentinal in the STAT shm, that would cause
           the accumulator to be reset the next time an addStat is called.
        -- Nice if we could zero out stats by their group (say MocbAdaptor, etc).
        -- Could probably use boost::fusion to visit each stat and clear it.


WfStatLoggerCtl.{h,cpp}
    --> Is only used by the wfstat utility.
    --> Must be told the enumeration to string mapping, e.g. LINK_STATE
    --> Need a mechanism to map strings <--> ComponentTypes. 
        One such method:
            fusion::vector<pair<Foo,
                           Bar,
                           Baz>;


wfstat interface (uses the WfStatLoggerCtl.cpp)
    -- List component layers:
            ./wfstat --get-components
                <will list all components as defined in the WfStatLogger.cpp>
    -- Hexdumps of pkts: 
            ./wfstat --hex-dump [<component-name>] #could have multiple component-names
        maybe we want an option to only grab the hexdumps of the individual components.
    -- Wf logs:
            ./wfstat --log-dump [<component-name>] #could have multiple component-names
        NOTE: for the WfLogs and Hexdumps, the wfstat utility should first copy the
            shm locations into a temporary buffer (to avoid a race condition).
        NOTE: Each sub-buffer will need to have the fields:
            * logSize (number of valid characters)
            * seq_number (used to correcly unwrap the log or hexdump)
    -- Wf performance stats:
            ./wfstat --stat [<component-name>] #no argument prints all components' stats
          Ex:
            ./wfstat --stat Sis
          will print something similar to:

                               PEER NODE LAYER1 RECEIVE STATUS          LAYER2 FEC    RX CORRELATOR INFO   RX ERR INFO     LINK INFO
     ================================================================+++++++++++++++++***********************================***********
     CMPLT    RF   FRMT ABRT BY INVAL FEC  CRC      HOP AQ   FILLERS  SLOTS   SLOTS   AVG   PEAK CORR1 CORR2 CUR ERR1  ERR2  LINKQ LINK
Node SUCCESS  FAIL FAIL NXT SLT LEN   FAIL FAIL     FAILURE  REC'VD   RECOVRD LOST    SCORE DIST THRSH THRSH ERR THRSH THRSH VALUE STATE
1 <-----------------------------my nodeId ----------------------------------------->
2    38694    0    0    0       0     0    0        150      37709    0       0       949   250  250   175   0   90    63    100   1HOP_SYMMETRIC
3    39819    0    0    0       0     0    0        375      38834    0       0       949   250  250   175   0   90    63    100   1HOP_SYMMETRIC
4    41094    0    0    0       0     0    0        450      40109    0       0       949   250  250   175   0   90    63    100   1HOP_SYMMETRIC
5    0        0    0    0       0     0    0        2576     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN
6    0        0    0    0       0     0    0        2951     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN
7    0        0    0    0       0     0    0        3477     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN
8    0        0    0    0       0     0    0        3552     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN

        This table can be generated by boost::fusion::for_each over the Sis stat fields. 

    -- Clear counters/stats
            ./wfstat --clear-stats [<component-name>]

    -- 




