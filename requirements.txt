RcStatLog requirements:

NOTE:
    wfStatus could either be a global variable OR a per "component" (e.g., MAC,
    SIS, etc.) variable.  I'm leaning towards the later because this would allow
    the wfstat utility to disable/enable hexdump, logging (and maybe even the
    stat collection) of particular components.  To do this the client (say
    MocbAdaptor) would do (on init):
        StatLogComponent wfStatus
            = statLogger.getWfStatusComponent<MocbAdaptorComponent>();
        This would be just a convenience wrapper arround these operations:
            statLogger.hexDump<MocbAdaptorComponent>(buffer, len, "Identifier");
            statLogger.getLogger<MocbAdaptorComponent>() << "Some string";
            statLogger.addStat<MocbAdaptorComponent::MocbStat1Tag>(value);
    then operate on the wfStatus (as specified below).
    The wfstat utility could do:
        > ./wfstat --get-registered-components
            ... MocbAdaptor ...
        > ./wfstat --disable MocbAdaptor [hexdump|log|stat|all] #the default would be all
    OR
        > ./wfstat --enable MocbAdaptor [hexdump|log|stat|all] #the default would be all

    Here, the name "MocbAdaptor" has been registered at compile time by the user passing
        this string to the API
    ISSUE: the wfstat application will have to enable/disable per-Component stats/logs
       by writing into the Component's "isEnabled" variable in SHM

NOTE:
    the circular buffer shms need to be protected with a mutex, this could be a
    performance issue ... One way to fix is to have fixed size sub-buffers in
    the circular buffer, and when the user logs (or hexdumps):
        writeLog(char* str, size_t len)
        {
            size_t num_sub_bufs = CEIL_DIVIDE(len, sub_buf_size);
            size_t sub_buf_idx_start
            lock
            {
                sub_buf_idx_start = next_sub_buf_idx;
                next_sub_buf_idx = (next_sub_buf_idx + num_sub_bufs)%NUM_SUB_BUFS
            }
            //Now copy in str to the location specified by sub_buf_idx_start
            //  with wrap-around
        }

NOTE:
    WfStatLogger should be a generic type that does not depend on all the
    component types.  This way we can avoid recompiling the entire waveform when
    the WfStatLogger.h changes.  In order to make this work, the
    WfStatLogger.cpp will instantiate the eTDRS-specific layout of shared_memory
    (this file will depend on all the component stat types).

* Pkt HexDump:
   INTERFACE:
        wfStatus.hexDump(buffer, len, "Identifier");
   Will create an entry in the HEX_DUMP shm circular buffer:
         <Component>:Identifier, size=<len>, timestamp=<current timestamp>
                01 02 03 ....
                ab ac ....
   where <Component> would be the string passed into registerWfStatusComponent()

* Logger:
    INTERFACE:
      either:
        wfStatus.getLogger() << "Some text ... " << foo ;
      or:
        wfStatus.logfmt("Some text ...  %d, %s", var, str);

      Both will prepend the current timestamp to the string
      and copy it to the LOGGING shm circular buffer
    NICE TO HAVES:
        -- A way to specify if a timestamp is to be prepended.
        -- wfStatus.logError("text");
            this will also copy the string to the LOGGING buffer.  In addition
            it will copy the LOGGING shm (maybe the others as well) to a
            temporary location so it can be inspected later without having to
            worry about logging rollovers.  Also would be nice if the copy
            didn't take place immediately because it might be useful to see how
            the waveform reacts to the fault in the immediate future.
        -- Have compile flag that will disable logging (so if optimization >=
            -02 is specified all logging processing goes away).

* Stat:
    INTERFACE:
        * To increment a static-location counter or statistic;
                wfStatus.addStat<MocbQueueDownTag>(1);
            or
                wfStatus.addStat<SnrStatTag>(45.0);
        * To add stat requiring runtime offset info:
                wfStatus.addStat<PerNbrSnrStatTag>(nbrId, 45.0);
        * To add stat requiring multiple runtime indicies:
                wfStatus.addStat<PerNbrRxStatusTag>(nbrId, rxstatus, 1);
            Here the traits of PerNbrRxStatusTag will know how to handle the args

    NICE TO HAVES:
        -- Need a way to reset the statistics via the wfstat.  This is simple
           for the trivial stats, but the boost::accumulator stats are more
           difficult because their guts are not stored in the STAT shm -- only
           their serializations are stored.  One possibility is for wfstat to
           put some sentinal in the STAT shm, that would cause the accumulator
           to be reset the next time an addStat is called. We also probably want
           to serialize the more "complicated" statistics in SHM on each
           "addStat" call ... instead we could have a low priority thread that
           will walk these stats and serialize them; this same thread can check
           the sentinals for reset as well.
        -- Nice if we could zero out stats by their group (say MocbAdaptor, etc).
        -- Could probably use boost::fusion to visit each stat and clear it.
        -- Time-Series stats (similar to OPNET).  Support both "bucket" and
           "all-values."  The user interface would still be the same:
               wfStatus.addStat<FooTag>(value);
           but the FooTag may specify (via template traits) that it is a
           TimeSeries stat.  This type of stat will store time-value pairs in a
           circular buffer (the size of this buffer will also be specified by a
           trait).  If collecting all stats is too expensive, the "bucket" stat
           would summarize the submitted values by their time-based "bins" --
           the summarize option would be something like: min, max, mean, etc.
        -- A particular tag, say FooTag, could have multiple back-end stats.
           For example, the traits for FooTag might specify that it is both:
                a) A simple counter statistic
                AND
                b) A time-series statistic
           In this case a
               wfStatus.addStat<FooTag>(value);
           would proxy to both stats under the covers of the library.


WfStatLoggerCtl.{h,cpp}
    --> Is only used by the wfstat utility.
    --> Must be told the enumeration to string mapping, e.g. LINK_STATE
    --> Need a mechanism to map strings <--> ComponentTypes.


wfstat interface (uses the WfStatLoggerCtl.cpp)
    -- List component layers:
            ./wfstat --get-components
                <will list all components as defined in the WfStatLogger.cpp>
    -- Hexdumps of pkts:
            ./wfstat --hex-dump [<component-name>] #could have multiple component-names
        maybe we want an option to only grab the hexdumps of the individual components.
    -- Wf logs:
            ./wfstat --log-dump [<component-name>] #could have multiple component-names
        NOTE: for the WfLogs and Hexdumps, the wfstat utility should first copy the
            shm locations into a temporary buffer (to avoid a race condition).
        NOTE: Each sub-buffer will need to have the fields:
            * logSize (number of valid characters)
            * seq_number (used to correcly unwrap the log or hexdump)
    -- Wf performance stats:
            ./wfstat --stat [<component-name>] #no argument prints all components' stats
            #NOTE: the Time-Series stats will NOT be printed in this way
          Ex:
            ./wfstat --stat Sis
            #TODO: define the "--stat" option that would print this table out in
            # more detail
          will print something similar to:

                               PEER NODE LAYER1 RECEIVE STATUS          LAYER2 FEC    RX CORRELATOR INFO   RX ERR INFO     LINK INFO
     ================================================================+++++++++++++++++***********************================***********
     CMPLT    RF   FRMT ABRT BY INVAL FEC  CRC      HOP AQ   FILLERS  SLOTS   SLOTS   AVG   PEAK CORR1 CORR2 CUR ERR1  ERR2  LINKQ LINK
Node SUCCESS  FAIL FAIL NXT SLT LEN   FAIL FAIL     FAILURE  REC'VD   RECOVRD LOST    SCORE DIST THRSH THRSH ERR THRSH THRSH VALUE STATE
1 <-----------------------------my nodeId ----------------------------------------->
2    38694    0    0    0       0     0    0        150      37709    0       0       949   250  250   175   0   90    63    100   1HOP_SYMMETRIC
3    39819    0    0    0       0     0    0        375      38834    0       0       949   250  250   175   0   90    63    100   1HOP_SYMMETRIC
4    41094    0    0    0       0     0    0        450      40109    0       0       949   250  250   175   0   90    63    100   1HOP_SYMMETRIC
5    0        0    0    0       0     0    0        2576     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN
6    0        0    0    0       0     0    0        2951     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN
7    0        0    0    0       0     0    0        3477     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN
8    0        0    0    0       0     0    0        3552     0        0       0       0     1250 250   175   0   90    63    70    UNKNOWN

        This table can be generated by boost::fusion::for_each over the Sis stat fields.

    -- To print individual stats:
            ./wfstat --stat <component-name>,<stat-name>

    -- Clear counters/stats
            ./wfstat --clear-stats [<component-name>,<stat-name>]

    -- To print time-series stats
            ./wfstat --stat --time-series [--output-type <output-type>] [<component-name>,[<stat-name>]]
        This will print the time/value series to the console in the format
        specified by output-type.  This output-type can be one of:
            * matlab
            * scipy
            * gnuplot
            * csv  (this will be the default)
    NOTE:
        If the stat-name isn't specified then all series stats under
        component-name will be printed (with a string identifier).  If, in
        addition, component-name is not specified ALL stats will be printed.
    NOTE:
        stat-name can have a "-N1[-M1][,N2-[-M2]]..." suffix where "N1" would
        specify the stat index.  The optional "-M1" would allow for specifying
        ranges of stats, e.g., "-3-8".  Specifying "*" as the "M1" index will be
        interpreted as the last index. If the statistic in question has more
        than one layer of indices (for example, the PerNbrStatus statistic where
        the first index may specify the nbr and the second may specify the
        enumeration representing the link status, e.g., 1HOP_SYMMETRIC, etc.)
        then multiple ranges may be used.  For example:
            NBR_LINK_STATUS-2,0-5
        would the 0th thru 5th nbr link status for neighbor 2. Another example
            NBR_LINK_STATUS-1-*,1
        would be the 1st nbr link status (say this is 1HOP_SYMMETRIC), for
        neighbors 1 thru the last configured neighbor.



